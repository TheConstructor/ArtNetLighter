/*
 * Dieses Werk ist unter einer Creative Commons Lizenz vom Typ Namensnennung - Weitergabe unter gleichen Bedingungen 3.0 Deutschland zugänglich. Um eine Kopie dieser Lizenz einzusehen, konsultieren Sie http://creativecommons.org/licenses/by-sa/3.0/de/ oder wenden Sie sich brieflich an Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
 *
 * Autor des "ArtNetLighter" ist Matthias Vill http://vom.tc/
 *
 * --
 *
 * This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Germany License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/de/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
 *
 * Author of "ArtNetLighter" is Matthias Vill http://vom.tc/
 *
 * --
 *
 * Art-Net™ Designed by and Copyright Artistic Licence Holdings Ltd
 */

package tc.vom.artNetLighter.infrastructure.packets;

import org.junit.Test;
import tc.vom.artNetLighter.infrastructure.constants.ArtNetOpCodes;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;

/**
 * Test case for {@link ArtPollReply}
 */
public class ArtPollReplyTest {
    public static byte[] captured_data1 = {0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x21, 0x02, 0x07, 0x5a, (byte) 0x91, 0x36, 0x19, 0x01, 0x01, 0x00, 0x00, 0x01, (byte) 0x90, 0x00, 0x02, 0x00, 0x00, 0x4d, 0x2e, 0x20, 0x56, 0x69, 0x6c, 0x6c, 0x20, 0x45, 0x6e, 0x74, 0x74, 0x65, 0x63, 0x20, 0x4f, 0x44, 0x00, 0x4d, 0x2e, 0x20, 0x56, 0x69, 0x6c, 0x6c, 0x20, 0x45, 0x6e, 0x74, 0x74, 0x65, 0x63, 0x20, 0x4f, 0x44, 0x45, 0x00, 0x00, 0x01, 0x00, 0x01, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x00, (byte) 0xff, 0x4f, (byte) 0xd6, 0x24, (byte) 0xde, 0x0b, (byte) 0x84, 0x0a, 0x40, 0x04, (byte) 0xcd, 0x0a, 0x2a, 0x52, (byte) 0xe0, 0x5a, (byte) 0xca, (byte) 0xe6, 0x24, 0x10, (byte) 0xe2, (byte) 0xaa, (byte) 0x94, 0x7e, (byte) 0xf4, 0x22, 0x02, (byte) 0xe6, 0x3a, (byte) 0xb3, (byte) 0xa4, (byte) 0x85, 0x38, (byte) 0xc3, (byte) 0xaa, 0x00, 0x08, (byte) 0xe2, 0x00, 0x49, 0x34, 0x72, 0x36, 0x1b, 0x02, 0x7b, 0x74, 0x2f, (byte) 0xc9, 0x34, (byte) 0xcc, 0x09, (byte) 0xa0, (byte) 0x84, (byte) 0xea, 0x45, 0x30, (byte) 0xc1, 0x72, (byte) 0x88, (byte) 0xb3, (byte) 0xd5, (byte) 0xd7, (byte) 0xca, 0x08, (byte) 0x82, (byte) 0x84, 0x2d, 0x14, 0x62, (byte) 0xb7, (byte) 0xe8, (byte) 0xef, 0x3f, (byte) 0xb6, (byte) 0xc4, (byte) 0xfb, 0x7e, 0x6f, 0x72, 0x6b, 0x37, (byte) 0xe7, 0x77, 0x3b, 0x39, 0x12, 0x3b, (byte) 0xcf, 0x7f, (byte) 0xea, (byte) 0xdb, (byte) 0xff, 0x7f, (byte) 0xd3, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, (byte) 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x80, 0x00, 0x00, 0x00, (byte) 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x31, (byte) 0x82, (byte) 0x81, 0x01, 0x02};
    public static byte[] cleaned_data1 = {0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x21, 0x02, 0x07, 0x5a, (byte) 0x91, 0x36, 0x19, 0x01, 0x01, 0x00, 0x00, 0x01, (byte) 0x90, 0x00, 0x02, 0x00, 0x00, 0x4d, 0x2e, 0x20, 0x56, 0x69, 0x6c, 0x6c, 0x20, 0x45, 0x6e, 0x74, 0x74, 0x65, 0x63, 0x20, 0x4f, 0x44, 0x00, 0x4d, 0x2e, 0x20, 0x56, 0x69, 0x6c, 0x6c, 0x20, 0x45, 0x6e, 0x74, 0x74, 0x65, 0x63, 0x20, 0x4f, 0x44, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, (byte) 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x80, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x31, (byte) 0x82, (byte) 0x81, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    @Test
    public void testConstants() throws Exception {
        assertEquals("Spare", 3, ArtPollReply.SPARE_BYTES.length);
        assertEquals("Filler", 26, ArtPollReply.FILLER_BYTES.length);
    }

    @Test
    public void testConstructFromBytes() throws Exception {
        ArtPollReply artPollReply = new ArtPollReply(captured_data1);
        assertEquals("OpCode", ArtNetOpCodes.OP_CODE_POLL_REPLY, artPollReply.getOpCode());
        assertEquals("IP Address", (2 << 24) | (7 << 16) | (90 << 8) | (145), artPollReply.getIpAddress());
        assertEquals("Port", 0x1936, artPollReply.getPort());
        assertEquals("Version Info", 0x0101, artPollReply.getVersionInfo());
        assertEquals("Net", 0, artPollReply.getNet());
        assertEquals("Sub-Net", 0, artPollReply.getSubNet());
        assertEquals("Oem", 0x0190, artPollReply.getOem());
        assertEquals("Ubea", 0, artPollReply.getUbea());
        assertEquals("Status1", 0x02, artPollReply.getStatus1());
        assertEquals("Esta LoHi", 0x0000, artPollReply.getEstaManufacturer());
        assertEquals("ShortName", "M. Vill Enttec OD", artPollReply.getShortName());
        assertEquals("LongName", "M. Vill Enttec ODE", artPollReply.getLongName());
        assertEquals("NodeReport", "", artPollReply.getNodeReport());
        assertEquals("NumPorts", 1, artPollReply.getNumPorts());
        assertArrayEquals("PortTypes", new byte[]{(byte) 0x80, 0, 0, 0}, artPollReply.getPortTypes());
        assertArrayEquals("GoodInput", new byte[]{0, 0, 0, 0}, artPollReply.getGoodInput());
        assertArrayEquals("GoodOutput", new byte[]{(byte) 0x80, 0, 0, 0}, artPollReply.getGoodOutput());
        assertArrayEquals("UniverseIn", new byte[]{0xc, 0, 0, 0}, artPollReply.getUniversesIn());
        assertArrayEquals("UniverseOut", new byte[]{0, 0, 0, 0}, artPollReply.getUniversesOut());
        assertEquals("Video", 0, artPollReply.getVideo());
        assertEquals("Macro", 0, artPollReply.getMacro());
        assertEquals("Remote", 0, artPollReply.getRemote());
        assertArrayEquals("Spare", new byte[]{0, 0, 0}, artPollReply.getSpare());
        assertEquals("Style", 0, artPollReply.getStyle());
        assertArrayEquals("Mac Address", new byte[]{0x32, 0x31, (byte) 0x82, (byte) 0x81, 0x01, 0x02}, artPollReply.getMacAddress());
        assertEquals("BindIp", 0, artPollReply.getBindIP());
        assertEquals("BindIndex", 0, artPollReply.getBindIndex());
        assertEquals("Status2", 0, artPollReply.getStatus2());
        assertArrayEquals("Filler", new byte[0], artPollReply.getFiller());
    }

    @Test
    public void testConstructPacket() throws Exception {
        ArtPollReply artPollReply = new ArtPollReply((2 << 24) | (7 << 16) | (90 << 8) | (145), 0x1936, 0x0101, 0, 0, 0x0190, 0, 0x02, 0x0000, "M. Vill Enttec OD", "M. Vill Enttec ODE", "", 1, new byte[]{(byte) 0x80, 0, 0, 0}, new byte[]{0, 0, 0, 0}, new byte[]{(byte) 0x80, 0, 0, 0}, new byte[]{0xc, 0, 0, 0}, new byte[]{0, 0, 0, 0}, 0, 0, 0, 0, new byte[]{0x32, 0x31, (byte) 0x82, (byte) 0x81, 0x01, 0x02}, 0, 0, 0);
        final byte[] actual = artPollReply.constructPacket();
        assertEquals("Length", ArtPollReply.PACKET_LENGTH, actual.length);
        assertArrayEquals(cleaned_data1, actual);
    }

    @Test
    public void testEquals() throws Exception {
        assertEquals(new ArtPollReply(captured_data1), new ArtPollReply(cleaned_data1));
    }
}
